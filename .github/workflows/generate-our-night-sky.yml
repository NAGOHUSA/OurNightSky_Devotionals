// generate-our-night-sky.js (v3)
// Failover: DeepSeek → OpenAI → Groq (optional x.ai Grok), retries, strict JSON,
// writes devotionals/YYYY-MM-DD.json (UTC). If all APIs fail and
// ALLOW_LOCAL_FALLBACK="1", writes a unique local fallback and DOES NOT hard-fail
// on duplicate-vs-yesterday (warns instead), so you never miss a day.

import fs from "fs";
import path from "path";
import crypto from "crypto";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// ---- Env / Config ----
const DEEPSEEK_API_KEY  = process.env.DEEPSEEK_API_KEY || "";
const OPENAI_API_KEY    = process.env.OPENAI_API_KEY   || "";
const GROQ_API_KEY      = process.env.GROQ_API_KEY     || "";
const GROK_API_KEY      = process.env.GROK_API_KEY     || ""; // optional x.ai

const DEEPSEEK_API_BASE = (process.env.DEEPSEEK_API_BASE || "https://api.deepseek.com/v1").replace(/\/+$/,"");
const OPENAI_API_BASE   = (process.env.OPENAI_API_BASE   || "https://api.openai.com/v1").replace(/\/+$/,"");
const GROQ_API_BASE     = (process.env.GROQ_API_BASE     || "https://api.groq.com/openai/v1").replace(/\/+$/,"");
const GROK_API_BASE     = (process.env.GROK_API_BASE     || "https://api.x.ai/v1").replace(/\/+$/,"");

const DEEPSEEK_MODEL    = process.env.DEEPSEEK_MODEL || "deepseek-chat";
const OPENAI_MODEL      = process.env.OPENAI_MODEL   || "gpt-4o-mini";
const GROQ_MODEL        = process.env.GROQ_MODEL     || "llama-3.1-8b-instant";
const GROK_MODEL        = process.env.GROK_MODEL     || "grok-2-latest";

const LOCATION          = process.env.ONS_LOCATION || "USA";
const THEME_DEFAULT     = process.env.ONS_THEME_DEFAULT || "wonder";
const ALLOW_LOCAL_FALLBACK = process.env.ALLOW_LOCAL_FALLBACK === "1";

// ---- Dates & paths ----
const DATE_UTC   = new Date().toISOString().slice(0, 10); // YYYY-MM-DD (UTC)
const OUT_DIR    = path.join(process.cwd(), "devotionals");
const OUT_FILE   = path.join(OUT_DIR, `${DATE_UTC}.json`);

// ---- Helpers ----
function sha256(s) { return crypto.createHash("sha256").update(s).digest("hex"); }

function extractJson(text) {
  try { return JSON.parse(text); } catch {}
  const fenced = text.match(/```(?:json)?\s*([\s\S]*?)```/i);
  if (fenced) { try { return JSON.parse(fenced[1]); } catch {} }
  const start = text.indexOf("{"); const end = text.lastIndexOf("}");
  if (start !== -1 && end > start) {
    try { return JSON.parse(text.slice(start, end + 1)); } catch {}
  }
  return null;
}

async function postWithRetries({name, url, key, body, attempts = 3}) {
  let lastErr;
  for (let i = 1; i <= attempts; i++) {
    try {
      const r = await fetch(url, {
        method: "POST",
        headers: {
          "Authorization": `Bearer ${key}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify(body)
      });
      if (r.status === 402) throw new Error(`${name} HTTP 402 (payment required)`);
      if (r.status === 429) throw new Error(`${name} HTTP 429 (rate limit/quota)`);
      if (!r.ok) throw new Error(`${name} HTTP ${r.status}`);
      const j = await r.json();
      const txt = j?.choices?.[0]?.message?.content?.trim();
      if (!txt) throw new Error(`${name} empty content`);
      return txt;
    } catch (e) {
      lastErr = e;
      const delay = [1000, 3000, 7000][Math.min(i-1, 2)];
      if (i < attempts) await new Promise(res => setTimeout(res, delay));
    }
  }
  throw lastErr;
}

function buildPrompt() {
  return [
    {
      role: "system",
      content:
        "You write Christian devotionals tied to the night's sky. " +
        "Return ONLY valid JSON in the requested schema. No prose, no markdown, no extra keys."
    },
    {
      role: "user",
      content:
`Write a short, uplifting devotional that blends the current night-sky context with Scripture.

Requirements:
- Date (UTC): ${DATE_UTC}
- Location: ${LOCATION}
- Tone: Encouraging, reverent, accessible
- Theme seed: ${THEME_DEFAULT}
- Keep scientific details plausible for mid-northern latitudes in this season (constellations, general moon phase, commonly visible planets, meteor showers if reasonable).

Output JSON ONLY (no code fences, no comments, no extra keys) in this schema:

{
  "app": "Our Night Sky",
  "id": "<uuid-v4 or unique hash>",
  "date": "${DATE_UTC}",
  "title": "<catchy devotional title>",
  "scriptureReference": "<Book Chapter:Verse>",
  "content": "<devotional in ~180–300 words, 1–2 short paragraphs>",
  "celestialConnection": "<1–2 sentences connecting scripture to the night's sky>",
  "theme": "<single word or short phrase>",
  "moonPhase": "<Waxing/Waning/Crescent/Gibbous/Full/New/Unknown>",
  "visiblePlanets": ["<Planet1>", "<Planet2>"],
  "createdAt": "<ISO8601 UTC timestamp>"
}`
    }
  ];
}

// ---- Provider adapters ----
async function callDeepSeek(messages) {
  if (!DEEPSEEK_API_KEY) throw new Error("DeepSeek missing API key");
  const url = `${DEEPSEEK_API_BASE}/chat/completions`;
  return postWithRetries({
    name: "DeepSeek",
    url,
    key: DEEPSEEK_API_KEY,
    body: { model: DEEPSEEK_MODEL, messages, temperature: 0.7, response_format: { type: "json_object" }, max_tokens: 900 }
  });
}

async function callOpenAI(messages) {
  if (!OPENAI_API_KEY) throw new Error("OpenAI missing API key");
  const url = `${OPENAI_API_BASE}/chat/completions`;
  return postWithRetries({
    name: "OpenAI",
    url,
    key: OPENAI_API_KEY,
    body: { model: OPENAI_MODEL, messages, temperature: 0.7, response_format: { type: "json_object" }, max_tokens: 900 }
  });
}

async function callGroq(messages) {
  if (!GROQ_API_KEY) throw new Error("Groq missing API key");
  const url = `${GROQ_API_BASE}/chat/completions`;
  return postWithRetries({
    name: "Groq",
    url,
    key: GROQ_API_KEY,
    body: { model: GROQ_MODEL, messages, temperature: 0.7, response_format: { type: "json_object" }, max_tokens: 900 }
  });
}

// Optional: x.ai Grok
async function callGrok(messages) {
  if (!GROK_API_KEY) throw new Error("Grok missing API key");
  const url = `${GROK_API_BASE}/chat/completions`;
  return postWithRetries({
    name: "Grok",
    url,
    key: GROK_API_KEY,
    body: { model: GROK_MODEL, messages, temperature: 0.7, response_format: { type: "json_object" }, max_tokens: 900 }
  });
}

// ---- Local fallback (always unique to date) ----
function approxMoonPhaseISO(dateStr) {
  // rough phase from date; 29.53-day synodic month
  const d = new Date(dateStr + "T00:00:00Z");
  const knownNew = new Date("2025-09-03T00:00:00Z");
  const days = (d - knownNew) / 86400000;
  const phase = ((days % 29.53) + 29.53) % 29.53;
  if (phase < 1.0) return "New";
  if (phase < 6.4) return "Waxing Crescent";
  if (phase < 8.9) return "First Quarter";
  if (phase < 14.8) return "Waxing Gibbous";
  if (phase < 15.8) return "Full";
  if (phase < 22.1) return "Waning Gibbous";
  if (phase < 24.7) return "Last Quarter";
  return "Waning Crescent";
}
function pick(arr, i) { return arr[i % arr.length]; }

function localFallbackDevotional({dateUTC, location, theme}) {
  const seeds = [
    {ref:"Psalm 19:1", tag:"Glory"},
    {ref:"Psalm 8:3-4", tag:"Wonder"},
    {ref:"Isaiah 40:26", tag:"Strength"},
    {ref:"Genesis 1:16", tag:"Creation"},
    {ref:"Philippians 2:15", tag:"Shine"},
    {ref:"James 1:17", tag:"Gifts"},
  ];
  const constellations = ["Cassiopeia","Andromeda","Cygnus","Pegasus","Perseus","Aquarius","Capricornus","Pisces"];
  const planetsSets = [
    ["Jupiter","Saturn"],
    ["Venus","Jupiter"],
    ["Mars","Jupiter"],
    ["Saturn","Mars"],
    ["Venus","Saturn"],
  ];
  const n = parseInt(sha256(dateUTC).slice(0,8), 16);
  const seed = pick(seeds, n);
  const cons = pick(constellations, n);
  const visPlanets = pick(planetsSets, n);
  const phase = approxMoonPhaseISO(dateUTC);

  const title = `${seed.tag} in the Night`;
  const scriptureReference = seed.ref;
  const themeOut = theme || seed.tag.toLowerCase();
  const celestialConnection = `Under ${cons} and a ${phase} Moon, we remember ${scriptureReference} in ${location}.`;
  const content = `As we look up on ${dateUTC}, the sky invites us to ${themeOut.toLowerCase()}. Even without a telescope, you can step outside, breathe, and notice the quiet order God set above us. Let this be your prayer: “Lord, tune my heart to see what You reveal in creation and to trust what You have promised in Your Word.”`;
  const body = content.trim();
  const id = sha256(`${dateUTC}|${title}|${scriptureReference}|${body}`).slice(0,32);

  return {
    app: "Our Night Sky",
    id,
    date: dateUTC,
    title,
    scriptureReference,
    content: body,
    celestialConnection,
    theme: themeOut,
    moonPhase: phase.includes(" ") ? phase.split(" ")[0] : phase,
    visiblePlanets: visPlanets,
    createdAt: new Date().toISOString(),
    usedProvider: null,
    isFallback: true,
    fallbackType: "local"
  };
}

// ---- Main ----
(async () => {
  try {
    if (!fs.existsSync(OUT_DIR)) fs.mkdirSync(OUT_DIR, { recursive: true });

    if (fs.existsSync(OUT_FILE)) {
      console.error(`Devotional for today already exists: ${OUT_FILE}`);
      process.exit(1);
    }

    const messages = buildPrompt();

    // Change order if you want Groq first; current order is DeepSeek → OpenAI → Groq → Grok(optional)
    const attempts = [
      { name: "DeepSeek", fn: () => callDeepSeek(messages) },
      { name: "OpenAI",   fn: () => callOpenAI(messages) },
      { name: "Groq",     fn: () => callGroq(messages) },
      // { name: "Grok",  fn: () => callGrok(messages) }, // enable if desired
    ];

    let usedProvider = null;
    let rawText = null;

    for (const a of attempts) {
      try {
        rawText = await a.fn();
        usedProvider = a.name;
        break;
      } catch (err) {
        console.warn(`[${a.name}] failed: ${(err && err.message) || err}`);
      }
    }

    // If all providers failed, write a local fallback (never miss a day)
    if (!rawText) {
      if (!ALLOW_LOCAL_FALLBACK) {
        console.error("All providers failed. No devotional written (fallback disabled).");
        process.exit(1);
      }
      const fb = localFallbackDevotional({ dateUTC: DATE_UTC, location: LOCATION, theme: THEME_DEFAULT });

      // For fallback days: WARN on exact duplicate vs yesterday, but DO NOT fail.
      const y = new Date(`${DATE_UTC}T00:00:00Z`); y.setUTCDate(y.getUTCDate() - 1);
      const yPath = path.join(OUT_DIR, y.toISOString().slice(0,10) + ".json");
      if (fs.existsSync(yPath)) {
        try {
          const prev = JSON.parse(fs.readFileSync(yPath, "utf8"));
          const prevHash = sha256(`${prev.title || ""}\n${prev.content || ""}`);
          const currHash = sha256(`${fb.title}\n${fb.content}`);
          if (prevHash === currHash) {
            console.warn("Local fallback content matches yesterday — proceeding anyway to avoid missing a day.");
          }
        } catch {}
      }

      fs.writeFileSync(OUT_FILE, JSON.stringify(fb, null, 2), "utf8");
      console.log(`Wrote local fallback: ${OUT_FILE}`);
      process.exit(0);
    }

    // Parse provider JSON
    const parsed = extractJson(rawText);
    if (!parsed || typeof parsed !== "object") {
      console.error("Provider returned non-JSON or unparseable JSON.");
      process.exit(1);
    }

    // Normalize + augment
    const nowIso = new Date().toISOString();
    parsed.app = "Our Night Sky";
    parsed.date = DATE_UTC;
    parsed.createdAt = parsed.createdAt || nowIso;

    const contentForHash = `${parsed.title || ""}\n${parsed.content || ""}\n${DATE_UTC}`;
    parsed.id = parsed.id || sha256(contentForHash).slice(0, 32);

    parsed.usedProvider = usedProvider;
    parsed.isFallback = false;

    if (!parsed.title || !parsed.content) {
      console.error("Parsed JSON missing required fields (title/content).");
      process.exit(1);
    }

    // Provider days: block exact duplicate vs yesterday
    const y = new Date(`${DATE_UTC}T00:00:00Z`); y.setUTCDate(y.getUTCDate() - 1);
    const yPath = path.join(OUT_DIR, y.toISOString().slice(0,10) + ".json");
    if (fs.existsSync(yPath)) {
      try {
        const prev = JSON.parse(fs.readFileSync(yPath, "utf8"));
        const prevHash = sha256(`${prev.title || ""}\n${prev.content || ""}`);
        const currHash = sha256(`${parsed.title}\n${parsed.content}`);
        if (prevHash === currHash) {
          console.error("Content matches yesterday — refusing to write duplicate.");
          process.exit(1);
        }
      } catch {}
    }

    fs.writeFileSync(OUT_FILE, JSON.stringify(parsed, null, 2), "utf8");
    console.log(`Wrote: ${OUT_FILE} via ${usedProvider}`);
  } catch (err) {
    console.error(`Fatal error: ${(err && err.stack) || err}`);
    process.exit(1);
  }
})();
